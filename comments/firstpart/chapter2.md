# 关于第二章的一些说明

## 线程安全的一些名词

#### 什么是线程安全性
当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，
并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，
那么就说这个类是线程安全的。
#### 一些规范性说明
如果当多个相称访问同一个可变的状态变量是没有使用合适的同步，
那么程序就会出项错误。有三种方式可以修复这个问题：
* 不在相称之间共享该状态变量。
* 将状态变量改为不可变的变量。
* 在访问状态变量是使用同步。
#### 另一些规范性说明
当设计相称安全的类时，良好的面向对象技术、不可修改性，以及明晰
的不可变性规范都能能起到一定的帮助作用。
#### 说明
* 在线程安全中封装必要的同步机制，
因此客户端无需进一步采取同步机制
* 无状态对象一定是线程安全的。

## 原子性
* 原子性
* 竞态条件
* 复合操作
在实际情况中，应尽可能地使用现有的线程安全对象（如AtomicLong,
AtomicReference）来管理类的状态。与非线程安全的对象相比，
判断线程安全对象的可能状态及其状态的转换情况要更为容易，从而也更容易
维护和验证线程安全性。

## 加锁机制
* 要保持状态的一致性，就需要在单个原子操作中更新所有相关
的状态变量
#### 内置锁
关键字synchronized
#### 重入
* 当线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞
* 内置锁是可重入的，即如果某个线程试图获取一个已经由它自己持有
的锁，那么这个请求就会成功。
* ‘重入’意味着获取锁的操作的粒度是‘线程’，而不是‘调度’。
###### 重入的一种实现方法
~~~
为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，
这个锁就被认为没有任何线程持有。当线程请求一个没有被持有的锁时，
JVM将记下锁的持有者，并且将计数值置为1。如果同一个线程再次获取这个锁，
计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。
当计数器值为0时，这个锁将被释放。
~~~
## 用锁来保护状态
* 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同
一个锁，在这中情况下，我们称这个状态变量是有这个锁保护的。
* 每个共享的和可变的都应该只有一个锁来保护，从而使维护人员知道是
哪个锁。
* 对于每个包含多个变量的不变性条件，
其中涉及的所有变量都需要由同一个锁来保护。
###### 一种常见的加锁约定
~~~
将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问
可变状态的代码路径进行同步，使得在该对象是不会发生并发访问。
~~~
## 活跃性与性能
* 通常，在简单性与性能之间存在者相互制约因素。
当实现摸个同步策略是，一定必要盲目地为了性能而牺牲
简单性（这可能破坏安全性）
* 当执行时间较长的计算或者可能无法快速完成的操作时（
例如，网络I/O或控制台I/O），一定不要持有锁。




